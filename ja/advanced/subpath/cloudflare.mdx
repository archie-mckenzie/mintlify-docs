---
title: "Cloudflare"
description: "Cloudflare Workers を使って /docs サブパスでドキュメントをホストする"
---

import Propagating from "/snippets/ja/custom-subpath-propagating.mdx";

Cloudflare でドキュメントを `/docs` サブパスにホストするには、Cloudflare Worker を作成して設定する必要があります。

<Info>
  始める前に、Cloudflare アカウントとドメイン名（Cloudflare 管理でも外部管理でも可）が必要です。
</Info>


<div id="set-up-a-cloudflare-worker">
  ## Cloudflare Worker をセットアップする
</div>

まだの場合は、[Cloudflare Workers のはじめ方ガイド](https://developers.cloudflare.com/workers/get-started/dashboard/)に従って Cloudflare Worker を作成してください。

<Warning>
  DNS プロバイダーが Cloudflare の場合は、CNAME レコードでプロキシを有効にしないでください。
</Warning>

<div id="proxies-with-vercel-deployments">
  ### Vercel デプロイでのプロキシ
</div>

Vercel のデプロイで Cloudflare をプロキシとして使用する場合は、Vercel のドメイン検証や SSL 証明書の発行と競合しないよう、正しく構成する必要があります。

不適切なプロキシ設定は、Vercel による Let's Encrypt の SSL 証明書の発行を妨げ、ドメイン検証の失敗を引き起こす可能性があります。

<div id="required-path-allowlist">
  #### 必須パスの許可リスト
</div>

Cloudflare Worker は、次のパスへのトラフィックをブロックやリダイレクトせずに許可する必要があります:

- `/.well-known/acme-challenge/*` - Let's Encrypt の証明書検証に必須
- `/.well-known/vercel/*` - Vercel のドメイン検証に必須

Cloudflare は多くの検証を自動処理しますが、追加のカスタムルールによってこの重要なトラフィックが誤ってブロックされる場合があります。

<div id="header-forwarding-requirements">
  #### ヘッダー転送の要件
</div>

Worker の設定で `HOST` ヘッダーが正しく転送されていることを確認してください。ヘッダーの転送が不適切だと、検証リクエストは失敗します。

<div id="configure-routing">
  ### ルーティングの設定
</div>

Cloudflare ダッシュボードで **Edit Code** を選択し、以下のスクリプトを Worker のコードに追加します。Worker の編集については、[Cloudflare のドキュメント](https://developers.cloudflare.com/workers-ai/get-started/dashboard/#development)を参照してください。

<Tip>
  `[SUBDOMAIN]` は固有のサブドメインに、`[YOUR_DOMAIN]` はサイトのベース URL に置き換えてください。
</Tip>

```javascript
addEventListener("fetch", (event) => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  try {
    const urlObject = new URL(request.url);
    
    // リクエストが Vercel の検証パスの場合はそのまま通す
    if (urlObject.pathname.startsWith('/.well-known/')) {
      return await fetch(request);
    }
    
    // リクエストが docs サブディレクトリ宛の場合
    if (/^\/docs/.test(urlObject.pathname)) {
      // Mintlify にプロキシする
      const DOCS_URL = "[SUBDOMAIN].mintlify.dev";
      const CUSTOM_URL = "[YOUR_DOMAIN]";

      let url = new URL(request.url);
      url.hostname = DOCS_URL;

      let proxyRequest = new Request(url, request);

      proxyRequest.headers.set("Host", DOCS_URL);
      proxyRequest.headers.set("X-Forwarded-Host", CUSTOM_URL);
      proxyRequest.headers.set("X-Forwarded-Proto", "https");
      // Vercel にデプロイする場合、クライアント IP を保持
      proxyRequest.headers.set("CF-Connecting-IP", request.headers.get("CF-Connecting-IP"));

      return await fetch(proxyRequest);
    }
  } catch (error) {
    // マッチしない場合は通常のリクエストとして処理
    return await fetch(request);
  }
}
```

**Deploy** を選択し、変更が反映されるまで待ちます。

<Propagating />

<div id="test-your-worker">
  ### Worker をテストする
</div>

コードをデプロイしたら、Worker が Mintlify のドキュメントに正しくルーティングするかテストします。

1. Worker のプレビュー URL でテスト: `your-worker.your-subdomain.workers.dev/docs`
2. Worker が Mintlify のドキュメントと自社サイトの両方にルーティングされることを確認します。

<div id="add-custom-domain">
  ### カスタムドメインを追加する
</div>

1. [Cloudflare ダッシュボード](https://dash.cloudflare.com/)で、対象の Worker に移動します。
2. **Settings > Domains & Routes > Add > Custom Domain** に進みます。
3. ドメインを追加します。

<Tip>
  `www.` あり・なしの両方のドメインを追加することをおすすめします。
</Tip>

詳しくは、Cloudflare ドキュメントの[「カスタムドメインを追加」](https://developers.cloudflare.com/workers/configuration/routing/custom-domains/#add-a-custom-domain)を参照してください。 

<div id="resolve-dns-conflicts">
  ### DNS の競合を解消する
</div>

ドメインがすでに別のサービスを向いている場合は、既存の DNS レコードを削除する必要があります。Cloudflare Workers がドメインのすべてのトラフィックを制御するように構成されている必要があります。

1. ドメインの既存の DNS レコードを削除します。詳細は Cloudflare のドキュメント「[Delete DNS records](https://developers.cloudflare.com/dns/manage-dns-records/how-to/create-dns-records/#delete-dns-records)」を参照してください。
2. Workers に戻り、カスタムドメインを追加します。

<div id="webflow-custom-routing">
  ## Webflow のカスタムルーティング
</div>

メインサイトのホスティングに Webflow を使用しており、同一ドメインの `/docs` で Mintlify ドキュメントを配信したい場合は、Cloudflare Workers でカスタムルーティングを設定し、ドキュメント以外のすべてのトラフィックをメインサイトへプロキシする必要があります。

<Warning>
  この Worker をデプロイする前に、メインサイトがランディングページで公開されるよう設定されていることを確認してください。未設定の場合、メインサイトの訪問者にエラーが表示されます。
</Warning>

1. Webflow で、メインサイト用のランディングページ（例: `landing.yoursite.com`）を設定します。訪問者がサイトにアクセスした際に表示されるページになります。
2. メインサイトをそのランディングページにデプロイします。これにより、Worker を設定している間もメインサイトへ問題なくアクセスできます。
3. 競合を避けるため、メインサイト内の絶対 URL は相対 URL に更新します。
4. Cloudflare で **Edit Code** を選択し、以下のスクリプトを Worker のコードに追加します。

<Tip> `[SUBDOMAIN]` は固有のサブドメイン、`[YOUR_DOMAIN]` はサイトのベース URL、`[LANDING_DOMAIN]` はランディングページの URL に置き換えてください。 </Tip>

```javascript
  addEventListener("fetch", (event) => {
  event.respondWith(handleRequest(event.request));
  });
  async function handleRequest(request) {
  try {
    const urlObject = new URL(request.url);
    
    // If the request is to a Vercel verification path, allow it to pass through
    if (urlObject.pathname.startsWith('/.well-known/')) {
      return await fetch(request);
    }
    
    // If the request is to the docs subdirectory
    if (/^\/docs/.test(urlObject.pathname)) {
      // Proxy to Mintlify
      const DOCS_URL = "[SUBDOMAIN].mintlify.dev";
      const CUSTOM_URL = "[YOUR_DOMAIN]";
      let url = new URL(request.url);
      url.hostname = DOCS_URL;
      let proxyRequest = new Request(url, request);
      proxyRequest.headers.set("Host", DOCS_URL);
      proxyRequest.headers.set("X-Forwarded-Host", CUSTOM_URL);
      proxyRequest.headers.set("X-Forwarded-Proto", "https");
      // If deploying to Vercel, preserve client IP
      proxyRequest.headers.set("CF-Connecting-IP", request.headers.get("CF-Connecting-IP"));
      return await fetch(proxyRequest);
    }
    // Route everything else to main site
    const MAIN_SITE_URL = "[LANDING_DOMAIN]";
    if (MAIN_SITE_URL && MAIN_SITE_URL !== "[LANDING_DOMAIN]") {
      let mainSiteUrl = new URL(request.url);
      mainSiteUrl.hostname = MAIN_SITE_URL;
      return await fetch(mainSiteUrl, {
        method: request.method,
        headers: request.headers,
        body: request.body
      });
    }
  } catch (error) {
    // If no action found, serve the regular request
    return await fetch(request);
  }
  }
  ```

5. **Deploy** を選択し、変更の反映が行き渡るまで待ちます。

<Propagating />