---
title: "パーソナライゼーションのセットアップ"
description: "ユーザーがログインしているときに、個別化されたドキュメント体験を提供"
icon: "user-cog"
---

パーソナライゼーションは、ユーザーがログイン中に各ユーザー向けにドキュメントを最適化します。たとえば、APIキーを自動入力したり、プランや役割に応じたコンテンツを表示したり、不要なセクションを非表示にできます。

<div id="personalization-features">
  ## パーソナライゼーション機能
</div>

以下のパーソナライゼーション機能でコンテンツを最適化・カスタマイズできます。

<div id="api-key-prefilling">
  ### APIキーの事前入力
</div>

ユーザーのデータで一致するフィールド名を返すと、APIプレイグラウンドの各フィールドにユーザー固有の値が自動入力されます。自動事前入力を有効にするには、ユーザーデータ内のフィールド名がAPIプレイグラウンドのフィールド名と完全に一致している必要があります。

<div id="dynamic-mdx-content">
  ### 動的なMDXコンテンツ
</div>

`user` 変数を使って、名前、プラン、組織などのユーザー情報に基づいて動的なコンテンツを表示します。

```jsx
Welcome back, {user.firstName}! Your {user.org?.plan} plan includes...
```

詳細な例と実装のガイダンスは、以下の[ユーザーデータ形式](#user-data-format)セクションを参照してください。

<div id="page-visibility">
  ### ページの可視性
</div>

ページのフロントマターに `groups` フィールドを追加して、ユーザーに表示するページを制限します。既定では、すべてのページがすべてのユーザーに表示されます。

ユーザーには、自分が所属している `groups` に含まれるページのみが表示されます。

```mdx
---
title: "Managing your users"
description: "Adding and removing users from your organization"
groups: ["admin"]
---
```

<div id="user-data-format">
  ## ユーザーデータ形式
</div>

パーソナライゼーションを実装する際、システムはコンテンツのカスタマイズを可能にする特定の形式でユーザーデータを返します。ハンドシェイク方法に応じて、このデータは生のJSONオブジェクトとして、または署名付きJWT内で送信できます。どちらもデータの構造は同じです。

```tsx
type User = {
  expiresAt?: number;
  groups?: string[];
  content?: Record<string, any>;
  apiPlaygroundInputs?: {
    header?: Record<string, any>;
    query?: Record<string, any>;
    cookie?: Record<string, any>;
    server?: Record<string, string>;
  };
};
```

<ParamField
  path="expiresAt"
  type="number"
>
  セッションの有効期限（**UNIXエポックからの秒数**）。この時間以降にユーザーがページを読み込むと、保存されたデータは自動的に削除され、再認証が必要になります。
  <Warning><b>JWTハンドシェイクの場合:</b> これはJWTの`exp`クレームとは異なり、JWTが無効と見なされるタイミングを決定します。セキュリティのため、JWTの`exp`クレームは短い期間（10秒以下）に設定してください。実際のセッション長（数時間〜数週間）には`expiresAt`を使用します。</Warning>
</ParamField>

<ParamField
  path="groups"
  type="string[]"
>
  ユーザーが所属するグループの一覧。フロントマターに一致する`groups`を持つページはこのユーザーに表示されます。

  **例**: `groups: ["admin", "engineering"]` のユーザーは、`admin` または `engineering` グループでタグ付けされたページにアクセスできます。
</ParamField>

<ParamField
  path="content"
  type="object"
>
  `user` 変数を介して`MDX`コンテンツ内から参照できるカスタムデータ。ドキュメント全体での動的なパーソナライゼーションに使用します。

  **基本例**:
  ```json
  { "firstName": "Ronan", "company": "Acme Corp", "plan": "Enterprise" }
  ```

  **`MDX`での使用例**:
  ```mdx
  Welcome back, {user.firstName}! Your {user.plan} plan includes...
  ```
  上記の例の`user`データでは、次のようにレンダリングされます: Welcome back, Ronan! Your Enterprise plan includes...

  **高度な条件付きレンダリング**:
  ```jsx
  Authentication is an enterprise feature. {
    user.org === undefined
      ? <>To access this feature, first create an account at the <a href="https://dashboard.mintlify.com/login">Mintlify dashboard</a>.</>
      : user.org.plan !== 'enterprise'
        ? <>You are currently on the ${user.org.plan ?? 'free'} plan. See <a href="https://mintlify.com/pricing">our pricing page</a> for information about upgrading.</>
        : <>To request this feature for your enterprise org, contact your admin.</>
  }
  ```

  <Note>
    `user` 内の情報はログイン済みユーザーにのみ利用可能です。ログアウトしているユーザーでは `user` の値は `{}` になります。ログアウト時にページがクラッシュするのを防ぐため、常に `user` の各フィールドにはオプショナルチェイニングを使用してください。例: `{user.org?.plan}`。
  </Note>
</ParamField>

<ParamField
  path="apiPlaygroundInputs"
  type="object"
>
  APIプレイグラウンドのフィールドを事前入力するユーザー固有の値。APIのテスト時にユーザーのデータを自動入力して時間を節約します。

  **例**:
  ```json
  {
    "header": { "X-API-Key": "user_api_key_123" },
    "server": { "subdomain": "foo" },
    "query": { "org_id": "12345" }
  }
  ```
  ユーザーが特定のサブドメインでリクエストを行う場合、`apiPlaygroundInputs` フィールドとして `{ server: { subdomain: 'foo' } }` を送信できます。この値は、`subdomain` を含むAPIページで自動的に事前入力されます。

  <Note>`header`、`query`、`cookie` フィールドは、あなたの[OpenAPIのセキュリティスキーム](https://swagger.io/docs/specification/authentication/)の一部である場合にのみ事前入力されます。フィールドが `Authorization` または `Server` セクションにある場合、事前入力されます。`Authorization` という名前の通常のヘッダーパラメーターを作成しても、この機能は有効になりません。</Note>
</ParamField>

<div id="example-user-data">
  ### ユーザー データ例
</div>

```json
{
  "expiresAt": 1735689600,
  "groups": ["admin", "beta-users"],
  "content": {
    "firstName": "Jane",
    "lastName": "Smith",
    "company": "TechCorp",
    "plan": "Enterprise",
    "region": "us-west"
  },
  "apiPlaygroundInputs": {
    "header": {
      "Authorization": "Bearer abc123",
      "X-Org-ID": "techcorp"
    },
    "server": {
      "environment": "production",
      "region": "us-west"
    }
  }
}
```

<div id="configuring-personalization">
  ## パーソナライゼーションの設定
</div>

構成するハンドシェイク方式を選択します。

<Tabs>
  <Tab title="JWT">
    ### 前提条件

    * JWT を生成して署名できるログインシステム
    * リダイレクトURLを作成できるバックエンドサービス

    ### 実装

    <Steps>
      <Step title="秘密鍵を生成します。">
        1. ダッシュボードで、[Authentication](https://dashboard.mintlify.com/settings/deployment/authentication) に移動します。
        2. **パーソナライゼーション** を選択します。
        3. **JWT** を選択します。
        4. 既存のログインフローのURLを入力し、**Save changes** を選択します。
        5. **Generate new key** を選択します。
        6. バックエンドからアクセスできるよう、キーを安全に保管します。
      </Step>

      <Step title="Mintlify のパーソナライゼーションをログインフローに統合します。">
        既存のログインフローに、ユーザーのログイン後に以下の手順を実行するように変更します:

        * ログイン済みユーザーの情報を `User` 形式で含む JWT を作成します。詳細は上記の [User data format](#user-data-format) セクションを参照してください。
        * ES256 アルゴリズムを使用して、秘密鍵で JWT に署名します。
        * JWT をハッシュとして含めて、ドキュメントに戻るリダイレクトURLを作成します。
      </Step>
    </Steps>

    ### 例

    ドキュメントは `docs.foo.com` でホストされています。ドキュメントをダッシュボードとは分離したい（またはダッシュボードがない）場合に、パーソナライゼーションを有効化します。

    まず JWT シークレットを生成します。次に、`https://foo.com/docs-login` にログインエンドポイントを作成し、ドキュメントへのログインフローを開始します。

    ユーザー資格情報の検証後:

    * Mintlify の形式でユーザーデータを含む JWT を生成します。
    * JWT に署名し、`https://docs.foo.com#{SIGNED_JWT}` にリダイレクトします。

    ```ts
    import * as jose from 'jose';
    import { Request, Response } from 'express';

    const TWO_WEEKS_IN_MS = 1000 * 60 * 60 * 24 * 7 * 2;

    const signingKey = await jose.importPKCS8(process.env.MINTLIFY_PRIVATE_KEY, 'ES256');

    export async function handleRequest(req: Request, res: Response) {
      const user = {
        expiresAt: Math.floor((Date.now() + TWO_WEEKS_IN_MS) / 1000),
        groups: res.locals.user.groups,
        content: {
          firstName: res.locals.user.firstName,
          lastName: res.locals.user.lastName,
        },
      };

      const jwt = await new jose.SignJWT(user)
        .setProtectedHeader({ alg: 'ES256' })
        .setExpirationTime('10 s')
        .sign(signingKey);

      return res.redirect(`https://docs.foo.com#${jwt}`);
    }
    ```

    ### ページアンカーの保持

    ログイン後に特定のセクションへリダイレクトするには、次のURL形式を使用します: `https://docs.foo.com/page#jwt={SIGNED_JWT}&anchor={ANCHOR}`。

    **例**:

    * 元のURL: `https://docs.foo.com/quickstart#step-one`
    * リダイレクトURL: `https://docs.foo.com/quickstart#jwt={SIGNED_JWT}&anchor=step-one`
  </Tab>

  <Tab title="OAuth 2.0">
    ### 前提条件

    * Auth Code with PKCE フローをサポートする OAuth サーバー
    * OAuth アクセストークンでアクセス可能な API エンドポイントを作成できること

    ### 実装

    <Steps>
      <Step title="ユーザー情報 API エンドポイントを作成します。">
        次を満たす API エンドポイントを作成します:

        * 認証のために OAuth アクセストークンを受け付ける。
        * `User` 形式でユーザーデータを返す。詳細は上記の [User data format](#user-data-format) を参照。
        * アクセス用のスコープを定義する。
      </Step>

      <Step title="OAuth のパーソナライゼーション設定を構成します。">
        1. ダッシュボードで [Authentication](https://dashboard.mintlify.com/settings/deployment/authentication) に移動します。
        2. **Personalization** を選択します。
        3. **OAuth** を選択し、次の項目を設定します:

        * **Authorization URL**: OAuth の認可エンドポイント。
        * **Client ID**: OAuth 2.0 のクライアント識別子。
        * **Scopes**: 要求する権限。スコープ文字列は**全体**をコピーする（例: `provider.users.docs` のようなスコープであれば、`provider.users.docs` 全体をコピー）。最初の手順で設定したエンドポイントのスコープと一致している必要があります。
        * **Token URL**: OAuth のトークン交換エンドポイント。
        * **Info API URL**: パーソナライゼーション用にユーザーデータを取得するエンドポイント。最初の手順で作成したもの。

        4. **Save changes** を選択します。
      </Step>

      <Step title="OAuth サーバーを構成します。">
        1. [authentication settings](https://dashboard.mintlify.com/settings/deployment/authentication) から **Redirect URL** をコピーします。
        2. OAuth サーバーの設定で、この URL を許可済みのリダイレクト URL として追加します。
      </Step>
    </Steps>

    ### 例

    あなたのドキュメントは `foo.com/docs` でホストされており、PKCE フローをサポートする既存の OAuth サーバーがあります。ユーザーデータに基づいてドキュメントをパーソナライズしたいとします。

    `provider.users.docs` スコープを持つ OAuth アクセストークンを要求し、ユーザーのカスタムデータで応答する `api.foo.com/docs/user-info` に**ユーザー情報エンドポイントを作成**します:

    ```json
    {
      "content": {
        "firstName": "Jane",
        "lastName": "Doe"
      },
      "groups": ["engineering", "admin"]
    }
    ```

    ダッシュボードで **OAuth サーバーの詳細を構成**します:

    * **Authorization URL**: `https://auth.foo.com/authorization`
    * **Client ID**: `ydybo4SD8PR73vzWWd6S0ObH`
    * **Scopes**: `['docs-user-info']`
    * **Token URL**: `https://auth.foo.com/exchange`
    * **Info API URL**: `https://api.foo.com/docs/user-info`

    **OAuth サーバーを構成**し、コールバック URL へのリダイレクトを許可します。
  </Tab>

  <Tab title="Shared session">
    ### 前提条件

    * Cookieベースのセッション認証を備えたダッシュボードまたはユーザーポータル。
    * ダッシュボードと同一オリジンまたはサブドメイン上にAPIエンドポイントを作成できること。
      * ダッシュボードが `foo.com` の場合、**API URL** は `foo.com` または `*.foo.com` で始まる必要があります。
      * ダッシュボードが `dash.foo.com` の場合、**API URL** は `dash.foo.com` または `*.dash.foo.com` で始まる必要があります。
    * ドキュメントがダッシュボードと同一ドメインまたはサブドメインでホストされていること。
      * ダッシュボードが `foo.com` の場合、**docs** は `foo.com` または `*.foo.com` でホストされている必要があります。
      * ダッシュボードが `*.foo.com` の場合、**docs** は `foo.com` または `*.foo.com` でホストされている必要があります。

    ### 実装

    <Steps>
      <Step title="ユーザー情報APIエンドポイントを作成する">
        次の要件を満たすAPIエンドポイントを作成します：

        * 既存のセッション認証でユーザーを識別する
        * `User` 形式でユーザーデータを返す（上記の[ユーザーデータ形式](#user-data-format)を参照）
        * APIドメインとdocsドメインが**完全一致しない**場合：

          * docsドメインをAPIの `Access-Control-Allow-Origin` ヘッダーに追加する（`*` は不可）。
          * APIの `Access-Control-Allow-Credentials` ヘッダーを `true` に設定する。

          <Warning>
            CORSヘッダーはこのエンドポイントのみに有効化し、ダッシュボードAPI全体には適用しないでください。
          </Warning>
      </Step>

      <Step title="パーソナライゼーション設定を構成する">
        1. ダッシュボードで [Authentication](https://dashboard.mintlify.com/settings/deployment/authentication) に移動します。
        2. **Personalization** を選択します。
        3. **Shared Session** を選択します。
        4. 最初の手順で作成したエンドポイントである **Info API URL** を入力します。
        5. ユーザーがダッシュボードにログインする **Login URL** を入力します。
        6. **Save changes** を選択します。
      </Step>
    </Steps>

    ### 例

    #### ダッシュボードがサブドメイン、docsがサブドメイン

    `dash.foo.com` にダッシュボードがあり、Cookieベースのセッション認証を使用しています。ダッシュボードのAPIルートは `dash.foo.com/api` でホストされています。`docs.foo.com` でホストされているdocs向けにパーソナライゼーションを設定したいとします。

    **セットアップ手順**:

    1. セッション認証でユーザーを識別し、ユーザーデータを返す **エンドポイント** `dash.foo.com/api/docs/user-info` を作成します。
    2. このルートにのみ **CORSヘッダー** を追加します:
       * `Access-Control-Allow-Origin`: `https://docs.foo.com`
       * `Access-Control-Allow-Credentials`: `true`
    3. 認証設定で **API URL** を設定します: `https://dash.foo.com/api/docs/user-info`。

    #### ダッシュボードがサブドメイン、docsがルート

    `dash.foo.com` にダッシュボードがあり、Cookieベースのセッション認証を使用しています。ダッシュボードのAPIルートは `dash.foo.com/api` でホストされています。`foo.com/docs` でホストされているdocs向けにパーソナライゼーションを設定したいとします。

    **セットアップ手順**:

    1. セッション認証でユーザーを識別し、ユーザーデータを返す **エンドポイント** `dash.foo.com/api/docs/user-info` を作成します。
    2. このルートにのみ **CORSヘッダー** を追加します:
       * `Access-Control-Allow-Origin`: `https://foo.com`
       * `Access-Control-Allow-Credentials`: `true`
    3. 認証設定で **API URL** を設定します: `https://dash.foo.com/api/docs/user-info`。

    #### ダッシュボードがルート、docsがルート

    `foo.com/dashboard` にダッシュボードがあり、Cookieベースのセッション認証を使用しています。ダッシュボードのAPIルートは `foo.com/api` でホストされています。`foo.com/docs` でホストされているdocs向けにパーソナライゼーションを設定したいとします。

    **セットアップ手順**:

    1. セッション認証でユーザーを識別し、ユーザーデータを返す **エンドポイント** `foo.com/api/docs/user-info` を作成します。
    2. 認証設定で **API URL** を設定します: `https://foo.com/api/docs/user-info`

    <Note>
      ダッシュボードとdocsが同一ドメインのため、CORSの設定は不要です。
    </Note>
  </Tab>
</Tabs>